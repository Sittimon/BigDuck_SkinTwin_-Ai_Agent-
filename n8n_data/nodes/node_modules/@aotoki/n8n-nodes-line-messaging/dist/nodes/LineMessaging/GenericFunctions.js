"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifySignature = verifySignature;
exports.apiRequest = apiRequest;
exports.apiDataRequest = apiDataRequest;
const crypto = __importStar(require("crypto"));
const n8n_workflow_1 = require("n8n-workflow");
var LineApiType;
(function (LineApiType) {
    LineApiType["MESSAGING"] = "messaging";
    LineApiType["DATA"] = "data";
})(LineApiType || (LineApiType = {}));
function getHttpStatusCode(error) {
    if (!error || typeof error !== 'object') {
        return undefined;
    }
    if ('statusCode' in error && typeof error.statusCode === 'number') {
        return error.statusCode;
    }
    if ('status' in error && typeof error.status === 'number') {
        return error.status;
    }
    if ('httpCode' in error && typeof error.httpCode === 'number') {
        return error.httpCode;
    }
    return undefined;
}
function createHttpErrorMessage(statusCode, error, apiType = LineApiType.MESSAGING) {
    const apiName = apiType === LineApiType.DATA ? 'LINE Data API' : 'LINE API';
    switch (statusCode) {
        case 401:
            return 'Invalid Channel Access Token. Please check your LINE credentials.';
        case 403:
            return 'Access denied. Please verify your LINE channel permissions.';
        case 404:
            return apiType === LineApiType.DATA
                ? 'Content not found. The message content may have expired or been deleted.'
                : 'Resource not found. The user or content may not exist.';
        case 429:
            return apiType === LineApiType.DATA
                ? 'Rate limit exceeded. Please wait before making more requests.'
                : 'Rate limit exceeded. Please wait before sending more messages.';
        case 500:
            return `${apiName} is temporarily unavailable. Please try again.`;
        default: {
            const message = error &&
                typeof error === 'object' &&
                'message' in error &&
                typeof error.message === 'string'
                ? error.message
                : 'Unknown error';
            return `${apiName} error (${statusCode}): ${message}`;
        }
    }
}
function verifySignature(channelSecret, signature, body) {
    const hmac = crypto.createHmac('sha256', channelSecret);
    hmac.update(body);
    const calculatedSignature = hmac.digest('base64');
    return signature === calculatedSignature;
}
async function apiRequest(method, endpoint, body, query, option = {}) {
    const options = {
        method,
        headers: {
            'Content-Type': 'application/json',
        },
        body,
        url: `https://api.line.me/v2/bot${endpoint}`,
        qs: query,
        json: true,
        ...option,
    };
    try {
        return await this.helpers.httpRequestWithAuthentication.call(this, 'lineMessagingApi', options);
    }
    catch (error) {
        const statusCode = getHttpStatusCode(error);
        let errorMessage;
        if (statusCode) {
            errorMessage = createHttpErrorMessage(statusCode, error, LineApiType.MESSAGING);
        }
        else if (error &&
            typeof error === 'object' &&
            'message' in error &&
            typeof error.message === 'string') {
            errorMessage = `LINE API error: ${error.message}`;
        }
        else {
            errorMessage = 'LINE API request failed';
        }
        throw new n8n_workflow_1.NodeApiError(this.getNode(), error, { message: errorMessage });
    }
}
async function apiDataRequest(method, endpoint, body, query, option = {}) {
    const options = {
        method,
        body,
        url: `https://api-data.line.me/v2/bot${endpoint}`,
        qs: query,
        json: true,
        ...option,
    };
    try {
        return await this.helpers.httpRequestWithAuthentication.call(this, 'lineMessagingApi', options);
    }
    catch (error) {
        const statusCode = getHttpStatusCode(error);
        let errorMessage;
        if (statusCode) {
            errorMessage = createHttpErrorMessage(statusCode, error, LineApiType.DATA);
        }
        else if (error &&
            typeof error === 'object' &&
            'message' in error &&
            typeof error.message === 'string') {
            errorMessage = `LINE Data API error: ${error.message}`;
        }
        else {
            errorMessage = 'LINE Data API request failed';
        }
        throw new n8n_workflow_1.NodeApiError(this.getNode(), error, { message: errorMessage });
    }
}
//# sourceMappingURL=GenericFunctions.js.map