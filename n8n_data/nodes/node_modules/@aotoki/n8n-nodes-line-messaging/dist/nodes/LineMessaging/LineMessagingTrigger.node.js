"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LineMessagingTrigger = void 0;
const n8n_workflow_1 = require("n8n-workflow");
const GenericFunctions_1 = require("./GenericFunctions");
const IWebhook_1 = require("./IWebhook");
class LineMessagingTrigger {
    constructor() {
        this.description = {
            displayName: 'Line Messaging Trigger',
            name: 'lineMessagingTrigger',
            icon: 'file:line.svg',
            group: ['trigger'],
            version: [1],
            defaultVersion: 1,
            usableAsTool: undefined,
            subtitle: '=Events: {{$parameter["events"].join(", ")}}',
            description: 'Starts the workflow on a Line Messaging update',
            defaults: {
                name: 'Line Messaging Trigger',
            },
            inputs: [],
            outputs: ["main"],
            credentials: [
                {
                    name: 'lineMessagingApi',
                    required: true,
                },
            ],
            webhooks: [
                {
                    name: 'default',
                    httpMethod: 'POST',
                    responseMode: 'onReceived',
                    path: 'webhook',
                },
            ],
            properties: [
                {
                    displayName: 'Trigger On',
                    name: 'events',
                    type: 'multiOptions',
                    default: [],
                    options: [
                        {
                            name: 'All',
                            value: '*',
                            description: 'Trigger on all events',
                        },
                        ...Object.values(IWebhook_1.EventType).map((event) => ({
                            name: event.charAt(0).toUpperCase() + event.slice(1),
                            value: event,
                            description: `Trigger on ${event} events`,
                        })),
                    ],
                },
            ],
        };
    }
    async webhook() {
        const credentials = await this.getCredentials('lineMessagingApi');
        const headers = this.getHeaderData();
        const req = this.getRequestObject();
        const bodyData = this.getBodyData();
        const receivedSignature = headers['x-line-signature'];
        const channelSecret = credentials.channelSecret;
        if (!receivedSignature) {
            throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'Missing x-line-signature header');
        }
        if (!channelSecret) {
            throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'Missing channel secret in credentials');
        }
        if (!(0, GenericFunctions_1.verifySignature)(channelSecret, receivedSignature, req.rawBody)) {
            const res = this.getResponseObject();
            res.status(403).json({ error: 'Invalid signature' });
            return {
                noWebhookResponse: true,
            };
        }
        const desiredEvents = this.getNodeParameter('events', []);
        let events = [];
        if (desiredEvents.includes('*')) {
            events = bodyData.events;
        }
        else if (desiredEvents.length > 0) {
            events = bodyData.events.filter((event) => desiredEvents.includes(event.type));
        }
        const eventsWithDestination = events.map((event) => ({
            ...event,
            destination: bodyData.destination,
        }));
        return {
            workflowData: [this.helpers.returnJsonArray(eventsWithDestination)],
        };
    }
}
exports.LineMessagingTrigger = LineMessagingTrigger;
//# sourceMappingURL=LineMessagingTrigger.node.js.map