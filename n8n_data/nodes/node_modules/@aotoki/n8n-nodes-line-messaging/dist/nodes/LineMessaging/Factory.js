"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MessageFactory = void 0;
const Message_1 = require("./Message");
const n8n_workflow_1 = require("n8n-workflow");
class MessageFactory {
    static createMessage(params) {
        const type = params.type;
        switch (type) {
            case Message_1.MessageType.TextV2:
                return this.createTextV2Message(params);
            case Message_1.MessageType.Flex:
                return this.createFlexMessage(params);
            default:
                throw new n8n_workflow_1.NodeOperationError({}, `Unsupported message type: ${type}. Currently only 'textV2' and 'flex' messages are supported.`);
        }
    }
    static createTextV2Message(params) {
        const message = {
            type: Message_1.MessageType.TextV2,
            text: params.text,
        };
        if (params.quoteToken) {
            message.quoteToken = params.quoteToken;
        }
        const quickReply = this.processQuickReply(params);
        if (quickReply) {
            message.quickReply = quickReply;
        }
        return message;
    }
    static createFlexMessage(params) {
        const altText = params.altText;
        const flexJson = params.flexJson;
        if (!altText || altText.trim() === '') {
            throw new n8n_workflow_1.NodeOperationError({}, 'Alt Text is required for Flex messages. Please provide alternative text for notifications.');
        }
        let contents;
        try {
            contents = JSON.parse(flexJson);
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : 'Unknown error';
            throw new n8n_workflow_1.NodeOperationError({}, `Invalid Flex Message JSON: ${errorMessage}. Please ensure your JSON is valid.`);
        }
        const message = {
            type: Message_1.MessageType.Flex,
            altText,
            contents,
        };
        const quickReply = this.processQuickReply(params);
        if (quickReply) {
            message.quickReply = quickReply;
        }
        return message;
    }
    static processQuickReply(params) {
        if (!params.quickReply || !params.quickReply.items) {
            return undefined;
        }
        const items = params.quickReply.items;
        if (!items || items.length === 0) {
            return undefined;
        }
        const quickReplyItems = items.map((item) => {
            const actionType = item.actionType;
            let action;
            if (actionType === Message_1.ActionType.Postback) {
                action = {
                    type: Message_1.ActionType.Postback,
                    label: item.label,
                    data: item.data,
                    displayText: item.label,
                };
            }
            else {
                action = {
                    type: Message_1.ActionType.Message,
                    label: item.label,
                    text: item.data,
                };
            }
            return {
                type: Message_1.QuickReplyItemType.Action,
                action,
            };
        });
        return {
            items: quickReplyItems,
        };
    }
}
exports.MessageFactory = MessageFactory;
//# sourceMappingURL=Factory.js.map