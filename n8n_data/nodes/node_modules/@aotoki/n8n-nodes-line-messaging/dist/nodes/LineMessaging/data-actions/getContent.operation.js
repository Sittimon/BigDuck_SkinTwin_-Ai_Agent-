"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.description = exports.properties = void 0;
exports.execute = execute;
const n8n_workflow_1 = require("n8n-workflow");
const GenericFunctions_1 = require("../GenericFunctions");
const utils_1 = require("../utils");
exports.properties = [
    {
        displayName: 'Message ID',
        name: 'messageId',
        type: 'string',
        default: '',
        required: true,
        placeholder: '1234567890',
        description: 'The ID of the message to retrieve content from',
    },
    {
        displayName: 'Binary Property',
        name: 'binaryPropertyName',
        type: 'string',
        default: 'data',
        required: true,
        description: 'The binary property to which to write the data to',
    },
    {
        displayName: 'Additional Options',
        name: 'additionalOptions',
        type: 'collection',
        placeholder: 'Add Option',
        default: {},
        options: [
            {
                displayName: 'Check Transcoding Status',
                name: 'checkTranscoding',
                type: 'boolean',
                default: false,
                description: 'Whether to check if content is ready before retrieving (useful for large files)',
            },
            {
                displayName: 'Retry Count',
                name: 'retryCount',
                type: 'number',
                default: 3,
                description: 'How many times to retry if content is still processing',
            },
            {
                displayName: 'Retry Interval (Seconds)',
                name: 'retryInterval',
                type: 'number',
                default: 3,
                description: 'How long to wait between retries in seconds',
            },
        ],
    },
];
exports.description = exports.properties;
async function execute(items) {
    const returnData = [];
    for (let i = 0; i < items.length; i++) {
        try {
            const messageId = this.getNodeParameter('messageId', i);
            const binaryPropertyName = this.getNodeParameter('binaryPropertyName', i);
            const additionalOptions = this.getNodeParameter('additionalOptions', i, {});
            if (additionalOptions.checkTranscoding === true) {
                const retryCount = additionalOptions.retryCount || 3;
                const retryInterval = (additionalOptions.retryInterval || 3) * 1000;
                let transcodingStatus = 'processing';
                let currentRetry = 0;
                while (transcodingStatus === 'processing' && currentRetry < retryCount) {
                    const response = await GenericFunctions_1.apiDataRequest.call(this, 'GET', `/message/${messageId}/content/transcoding`, {});
                    if (response &&
                        typeof response === 'object' &&
                        'status' in response &&
                        typeof response.status === 'string') {
                        transcodingStatus = response.status;
                    }
                    if (transcodingStatus === 'processing') {
                        await (0, n8n_workflow_1.sleep)(retryInterval);
                        currentRetry++;
                    }
                    else if (transcodingStatus === 'failed') {
                        throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'Content transcoding failed. The file may be corrupted or unsupported.');
                    }
                }
                if (transcodingStatus === 'processing') {
                    throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'Content is still processing after maximum retries. Try again later or increase retry count.');
                }
            }
            const response = (await GenericFunctions_1.apiDataRequest.call(this, 'GET', `/message/${messageId}/content`, {}, {}, {
                encoding: 'arraybuffer',
                json: false,
                returnFullResponse: true,
            }));
            let contentType = 'application/octet-stream';
            const responseBody = response.body;
            if ('headers' in response) {
                contentType = response.headers['content-type'] || contentType;
            }
            if (!responseBody) {
                throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'Failed to retrieve content data from LINE API');
            }
            const fileExtension = (0, utils_1.getFileExtension)(contentType);
            const fileName = `line_content_${messageId}${fileExtension}`;
            const binaryData = await this.helpers.prepareBinaryData(responseBody, fileName, contentType);
            const newItem = {
                json: {
                    messageId,
                    success: true,
                    contentType,
                },
                binary: {
                    [binaryPropertyName]: binaryData,
                },
                pairedItem: {
                    item: i,
                },
            };
            returnData.push(newItem);
        }
        catch (error) {
            if (this.continueOnFail()) {
                returnData.push({
                    json: {
                        success: false,
                        error: error.message,
                    },
                    pairedItem: {
                        item: i,
                    },
                });
                continue;
            }
            throw error;
        }
    }
    return returnData;
}
//# sourceMappingURL=getContent.operation.js.map